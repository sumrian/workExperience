## v8事件循环之微队列是唯一的还是归属于每一个宏任务的

微队列git地址：https://chromium.googlesource.com/v8/v8/+/refs/heads/main/src/execution/microtask-queue.h

关键代码：static std::unique_ptr<MicrotaskQueue> New(Isolate* isolate);

微任务队列的创建和初始化主要通过`MicrotaskQueue::New`方法完成。该方法接受一个`Isolate`对象作为参数，并返回一个指向新创建的`MicrotaskQueue`对象的智能指针。`Isolate`是V8引擎中的独立执行环境，每个`Isolate`都有自己的微任务队列。

同一个Isolate环境 → **同一个微任务队列**
同一个JavaScript执行环境（如浏览器的一个标签页或Node.js的一个进程）中运行，因此所有操作共享同一个`Isolate`实例和对应的`MicrotaskQueue`。



所以在一个标签页内只有一个`Isolate`实例



在谷歌浏览器（Chromium）的源码中，`MicrotaskQueue::New(Isolate* isolate)`方法的调用通常发生在以下场景中：

创建新的JavaScript上下文（Context）时**
当需要创建一个新的v8::Context时（例如打开新的标签页或iframe），Chromium会调用此方法来初始化关联的微任务队列。例如：

```
Local<Context> context = Context::New(isolate, nullptr, ..., microtask_queue);
```

运行

如果未显式提供microtask_queue参数，则会内部调用New方法创建一个默认的。

### **1. V8 Isolate (主线程)初始化时**

当浏览器主线程初始化 V8 Isolate (JavaScript引擎实例)时，会调用 `SetUpDefaultMicrotaskQueue()`：

```
// src/v8/src/execution/isolate.cc
void Isolate::Init(...) {
    ...
    if (FLAG_harmony_top_level_await) {
        MicrotaskQueue::SetUpDefaultMicrotaskQueue(this); // <-- Here!
    }
    ...
}
```

运行

随后在 `SetUpDefaultMicrotaskQueue()`内部会调用 `New()`：

```
// src/v8/src/execution/microtask-queue.cc
void MicrotaskQueue::SetUpDefaultMicrotaskQueue(Isolate* isolate) {
    ...
    default_microtask_queue_ = New(isolate); // <-- Creates the default queue!
    ...
}
```

运行

------

### **2. Web Worker (工作线程)初始化**

每个 Web Worker (包括 Service Worker)都会有自己的 V8 Isolate + MicroTask Queue：

```
// src/third_party/blink/renderer/core/workers/worker_thread.cc
void WorkerThread::InitializeOnWorkerThread(...) {
    ...
    v8::Local<v8::Context> context = creator_->CreateWorkerContext();
    
    // Inside CreateWorkerContext():
    std::unique_ptr<v8::MicrotaskQueue> queue = 
        v8::MicrotaskQueue::New(isolate); // <-- Worker gets its own queue!
    
    v8::Local<v8::Context> context = 
        v8::Context::New(isolate, nullptr, nullptr, queue.get());
    ...
}
```

运行

WorkerThread确保每个工作线程都有独立的 JS Context + MicroTask Queue。

------

### **3. Blink Frame (页面/iframe)初始化**

当浏览器加载新页面或 `<iframe>`时：

```
// src/third_party/blink/renderer/core/frame/local_dom_window.cc
LocalDOMWindow::LocalDOMWindow(...) {
    ...
    if (RuntimeEnabledFeatures::TopLevelAwaitEnabled()) {
        microtask_queue_ = v8::MicrotaskQueue::New(isolate); // <-- Per-frame queue!
        InitializeV8Context(context_args, microtask_queue_.get());
    }
}
```

运行

某些高级特性（如 Top-Level Await）会让每个 Frame/iframe拥有自己的 `MicroTaskQueue`。

------

### **4. V8/Blink测试用例**

测试代码通常会显式创建 `MicroTaskQueue`：

```
// src/v8/test/cctest/test-microtask.cc
TEST(MicroTaskQueueBasic) {
    ...
    std::unique_ptr<v8::MicrotaskQueue> queue = 
        v8::MicrotaskQueue::New(isolate); // <-- Test-specific queue!
    
    v8::Local<v8::Context> context = 
        v8::Context::New(isolate, nullptr, nullptr, queue.get());
    ...
}
```

运行

测试用例需要精确控制 MicroTask的执行时机。