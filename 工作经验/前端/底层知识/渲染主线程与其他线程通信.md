## 渲染主线程与其他线程通信



根据 Chromiunm **源码实现逻辑**和资料分析：

------

### **1. setTimeout跨线程通信全流程**

#### **(1) Renderer进程 → Browser进程**

当JS调用`setTimeout()`时：

1. Blink创建DelayTask并提交给Renderer的主线程IPC通道

   - 关键文件

     :

      

     ```
     third_party/blink/renderer/core/timing/dom_timer.cc
     ```

     ```
     int DOMTimer::Install(ExecutionContext* context,
                          ScheduledAction* action,
                          base::TimeDelta timeout,
                          bool single_shot) {
       // ...生成timer_id...
       context->GetTaskRunner(TaskType::kJavascriptTimer)
           ->PostDelayedTask(FROM_HERE, 
                            BindOnce(&DOMTimer::Fire, timer), 
                            timeout); 
     } 
     ```

     运行

- `PostDelayedTask()`通过Mojo IPC将请求发送到Browser进程(<https://chromiums.googlesource.com/chromium/src.git/+/master/third_party/blink/renderer/core/timing/DOMTimer.cpp>)([https://chromiums.googlesource.com/chromiums.git)。](https://chromiums.googlesource.com/chromiums.git)%E3%80%82)

1. Browser进程接收并注册系统级计时器

   - 关键文件

     :

      

     ```
     content/browser/timer/timer_service.cc
     ```

     ```
     void TimerService::OnTimerFired() { 
       mojo::Remote<blink::mojom::TimerDispatcher> dispatcher;
       dispatcher->DispatchTimerCallback(timer_id); // IPC回传Renderer 
     } 
     ```

     运行

- Browser主线程(`CrBrowserMain`)通过OS级API（如Windows的`SetTimer()`或Mac的CFRunLoop）启动系统计时器([https://chromiums.googlesource.com](https://chromiums.googlesource.com/))([https://chromiums.googlesource.com)。](https://chromiums.googlesource.com)./)

#### **(2) Timer触发 → Browser → Renderer**

当系统计时器到期时：

1. **OS通知Browser进程的IOThread**

   - Windows/Mac底层通过消息泵(

     ```
     MessagePump
     ```

     )唤醒

     ​

     (

     https://chromiums.googlesource.com

     ):

     ```
     void MessagePumpForUI::ScheduleNativeTimer(...) { 
       ::SetTimer(..., delay_ms); // Windows API 
     } 
     ```

     运行

2. **Browser通过Mojo IPC回传Renderer**

   - 关键文件

     :

      

     ```
     content/renderer/render_thread_impl.cc
     ```

     ```
     void RenderThreadImpl::OnDispatchTimer(int timer_id) { 
       main_thread_task_runner_->PostTask(
           FROM_HERE, base::BindOnce(&RunTimerCallback, timer_id)); 
     } 
     ```

     运行

#### **(3) Renderer主线程 → TaskQueue**

最终由Renderer的主线程将回调加入消息队列：

```
// third_party/blink/renderer/platform/scheduler/main_thread/task_queue_impl.cc 
void TaskQueueImpl::PushOntoImmediateWorkQueue(Task task) { 
 immediate_work_queue_->Push(std::move(task)); 
} 
```

运行

------

### **2. Chromiunm源码层级验证**

| 步骤                  | 关键类/文件               | 跨线程方式                   |
| --------------------- | ------------------------- | ---------------------------- |
| JS调用→Blink          | DOMTimer.cpp              | Mojo IPC                     |
| Blink→Browser         | timer_service.cc          | Mojo(BrowserInterfaceBroker) |
| Browser→OS            | message_pump_{win/mac}.cc | 系统API(`SetTimer`)          |
| OS→Browser IOThread   | message_pump_default.cc   | OS事件                       |
| Browser→Renderer      | render_thread_impl.cc     | Mojo IPC                     |
| Renderer→MessageQueue | task_queue_impl.cc        | PostTask                     |

------

### **3. W3C规范与源码对应关系**

OS TimerBrowser ProcessRenderer Main ThreadJS Engine(V8)OS TimerBrowser ProcessRenderer Main ThreadJS Engine(V8)setTimeout()触发DOMTimerMojo IPC发送timer注册请求SetTimer(delay_ms)Timer到期事件Mojo IPC回传timer_idPushOntoImmediateWorkQueue()

------

### **总结**

1. **跨三次IPC跳转**: Renderer → Browser → OS → Browser → Renderer
2. **最终入队**: Renderer主线程通过`TaskQueueImpl::PushOntoImmediateWorkQueue()`将回调加入普通消息队([https://chromiums.googlesource.com)。](https://chromiums.googlesource.com)./)

### **1. setTimeout(fn,0)的执行流程**

当渲染主线程遇到同步代码中的 `setTimeout(fn,0)`时：

#### **(1) JS引擎阶段（同步代码）**

1. **注册定时器**
   V8引擎调用Blink的DOMTimer接口生成一个延迟为0的任务：

   ```
   // third_party/blink/renderer/core/timing/dom_timer.cc 
   int DOMTimer::Install(...) { 
     context->GetTaskRunner()->PostDelayedTask(
         BindOnce(&DOMTimer::Fire, timer), delay); // delay=0 
   } 
   ```

   运行

   - **此时仍在同步JS上下文中**(#)，尚未跳出当前调用栈。

2. **跨进程通信启动**
   Blink通过Mojo IPC将定时器注册请求发送到Browser进程：

   ```
   // content/browser/timer/timer_service.cc 
   void TimerService::AddTimer(...) { 
     mojom::TimerDispatcher->Register(timer_id); 
   } 
   ```

   运行

   - IPC通信由Browser进程的其他独立IOThread处理(#)，不会阻塞JS引擎。

#### **(2) Browser进程响应**

1. Browser收到IPC后立即将timer_id加入延迟队列表述可能不准确？(#)，并通过系统API注册计时器：

   ```
   void MessagePumpForUI::ScheduleNativeTimer(...) { 
     ::SetTimer(..., delay_ms); // Windows API最小间隔4ms (#)
   } 
   ```

   运行

   - **即使delay=0也会强制修正为最小值4ms**[16]。

#### **(3) Timer到期回传Renderer**

由于delay=0且系统计时器已最小化延迟：

1. Browser进程IOThread通过Mojo IPC回传timer_id给Renderer(#)。

2. Renderer的IOChildThread接收后生成一个PendingTask：

   ```
   void RenderThreadImpl::OnMsgTimerFired(int timer_id) { 
     main_thread_task_runner_->PostTask(FROM_HERE, BindOnce(&RunCallback)); 
   } 
   ```

   运行

#### **(4) Renderer主线程处理顺序**

此时渲染主可能处于两种状态：

##### **状态A：仍在同步JS上下文中**

- PostTask仅将回调加入PendingTasks缓冲队列表述可能不准确？(#)，不会立即插入消息队列表述可能不准确？(#)。
- JS继续同步执行的剩余代码(#)。

##### **状态B：同步代码已结束**

- Event Loop检查PendingTasks并将其推入可执行的WorkQueue(#):

```
void TaskQueueImpl::PushOntoImmediateWorkQueue(Task task) { 
 immediate_work_queue_->Push(std::move(task)); //进入可消费状态(#)
} 
```

运行

------

### **2. W3C规范与Chromiunm实现的对应关系**

BrowserRenderer Main ThreadJS Engine(V8)BrowserRenderer Main ThreadJS Engine(V8)Browser进程IPC独立处理不阻塞JS (par[JS继续同步代码][Browser响应计时器]setTimeout(fn,0)(同步阶段)console.log("后续同步代码") (PostTask回传fn (Event Loop将fn加入WorkQueue (

------

### **关键结论**

1. **IPC通信不阻塞JS**: Browser/Renderer间Mojo IPC由独立IOThread处理(#)，不影响JS同步代码继续运行(#)(#)。

2. **延迟强制修正**: delay=0会被强制设为4ms+(#)，但PostTask仍可能早于同步结束到达(#)。

3. 最终入队时机

   : fn实际插入可消费WorkQueue的时间取决于Event Loop当前状态

   ​

   (#):

   - *若同步未结束*→暂存PendingTasks缓冲表述可能不准确？(#)。
   - *若同步已结束*→直接推入WorkQueue(#)(#)。