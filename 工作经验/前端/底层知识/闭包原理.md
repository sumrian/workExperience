## 闭包原理

闭包的存在给v8惰性解析带来了压力，引入了预解析器，核心概念是预解析器在编译阶段会对函数于解析，

1：观察是否有语法错误（发现立即停止报错，不会编译后续代码）

2：把函数内被引用的变量复制到堆中

父函数在运行时候仍然会创建被复制到堆的变量，但是修改会同步更新堆中的变量

闭包的核心原理确实与预解析器对变量的处理方式密切相关。以下是更深入的技术解析：

------

### ▶ I.闭包变量的存储机制原理

#### 🔍预解析阶段的关键行为（以Chrome/V为例）

1️⃣ **变量引用分析**
预解析器会构建完整的AST作用域链 ▼标记所有跨函数引用关系▼:

```
function outer() {
 let a = ;      /*被引用→提升至堆*/
 let b = ;      /*未被引用→保留在栈*/
 return function inner() { console.log(a); }
}
```

👉🏻 *输出结果*: `a被标记为ClosureVar`

2️⃣ **选择性堆分配**
只有被内层函数引用的变量才会转移存储位置 ▼通过隐藏类(Hidden Class)跟踪关联性▼:

```
内存结构变化示例 ▼仅提升被引用的a变量▼:
┌─────────────┐          ┌─────────────┐        
│    栈       │          │    堆       │        
├─────────────┤          ├─────────────┤        
│ outer帧     │──a──────▶│ Closure(a) │        
│ b=123       │          └─────────────┘        
└─────────────┘               ▲                            
                              │                            
                       ┌─────────────┐        
                       │ inner函数    │        
                       │ [[Scopes]]──┘        
                       └─────────────┘        
```

3️⃣ **编译优化**
Ignition解释器生成字节码时 ▼对闭包变量采用特殊访问指令(LdaNamedPropertyFromSuper)▼:

```
字节码示例 ▼对比普通变量访问指令▼:
LdaGlobal [a]         ←普通变量访问指令 !
LdaNamedPropertyFromSuper [a] ←闭包变量访问指令 !
```

------

### ▶ II未被引用的变量如何处置？

#### 📌严格按需提升原则 ▼验证案例▼:

```
function test() {
 let used = ; /*被引用→进堆*/
 let unused = ; /*未引用→留栈*/
 return () => used; 

const closure = test();
console.dir(closure); 
/*调试输出 ▼Scopes属性仅含used变量▼:
[[Scopes]]:[ Closure(test){ used } ]
*/
```

⚠️ **GC回收证据**
通过Chrome Memory面板可观测到 ▼未被引用的unused变量随test()执行结束被回收▼:

Memory面板截图

------

### ▶ III底层实现差异对比表

|                                                  | 被引用的闭包变量(a) | 未被引用的变量(b) | 临时变量   |
| ------------------------------------------------ | ------------------- | ----------------- | ---------- |
| 存储位置                                         |                     | 栈                |            |
| [内存回收时机](https://v.dev/blog/scavenge)      | 随闭包生命周期      |                   | 随函帧销毁 |
| [访问速度](https://mrale.ph/blog/)▲慢%▲快%▲最快% |                     |                   |            |

关键优化点：
✅ **减少%不必要的堆内存占用** （尤其对大型临时对象）
✅ **维持%正常的栈帧销毁逻辑** （避免内存泄漏）
✅ **加速%未被引用变量的访问** （保持寄存器优化可能性）

------

### ▶ IV特殊场景下的保守策略

当出现以下情况时 ▼会退化为全量提升策略▼:
1️⃣ **动态作用域** (`eval`或`with`)

```
function risky() {
 let x = ; /*本可不提升*/
 eval("()=>console.log(x)"); /*强制提升x*/
}
```

👉🏻 *编译警告*: `Optimization bailout due to dynamic scope usage`

2️⃣ **非严格模式arguments** ▼隐式绑定所有形参▼:

```
function legacy(a,b){
 arguments[]=; /*非严格模式下强制提升a,b*/
 return ()=>a;
}
```

------

总结来说 ▲现代J引擎通过预解析阶段的精准引用分析 ▲实现了闭包变量的**按需堆分配** ▲这种机制既解决了闭包的核心需求 ▲又避免了无差别内存提升的性能损耗 。