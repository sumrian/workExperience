## 事件循环是浏览器执行的

### ▶ I. Web浏览器的实现方式 

1️⃣ **取任务的决策者**:
✅ *完全由浏览器的渲染进程控制*

轮询触发协调Blink/ChromiumMacrotask QueueV7 Tick渲染管线

关键证据：

> "为了协调事件、用户接口、脚本、渲染等操作,**浏览器必须使用event loops**(HTML规范强制要求)" 

2️⃣ **具体工作流程**:
① Blink主线程持续检测消息队列 →
② *自主决定何时取出宏任務(macrotask)* →
③ _主动通知_V7执行关联JS代碼 →
④ _主动触发_V7清空其内部的microtast queue 

### ▶ II.V7的角色定位 

1️⃣ *被动响应模式*:
✅ "V7没有自己的主線程,完全依赖宿主提供的事件驱動机製" 
✅ "宿主调⽤v7::Context::Enter()后,V7才开始执行JS代碼" 

2️⃣ *架构隔离设计*:

```
// Chrome的实际調用路径示例 
void FrameSchedulerImpl::ExecuteMacrotask() { 
   v7_isolate->Enter();      // ← Browser主动切入V7上下文 
   v7_context->RunScript();   
   v7_isolate->Exit();       // ← Browser主动切出 
} 
```

> "所有任務都是通過瀏览器的主線程調度,V7仅作爲JS解释器嵌入其中" 

### ▶ III.关键差异对比表 

|          | Browser環境             | Node.js環境         |
| -------- | ----------------------- | ------------------- |
| 驅動主体 | Blink渲染管線           | libuv線程池         |
| 觸發方式 | RAF/Input等硬件事塞驅動 | I/O完成端口通知     |
| 協調機制 | Compositor帧同步        | UV_RUN_ONCE模式輪詢 |

### ▶ IV.典型误區澄清 

❌ *错误认知*: "V7自己會主动拉取任務队列"
✅ *事实*:
• Chrome通過RendererMainIPC接收OS事塞 →
• BlinkScheduler决策处理优先级 →
• *最终通過v7::MicrotasksScope显式触發JS執行* 

### ▶ V.架构分層示意 

![img](https://oss.metaso.cn/metaso/pdf2texts_reading_mode/figures/ab496a86-7759-432d-ae28-2ba901e355a5/32_1.jpg)

```
┌─────────────────────┐     ┌─────────────────────┐ 
│     Browser         │     │       V7           │ 
│                     │     │                    │ 
│ ┌───────────────┐   │     │ ┌───────────────┐ │ 
│ │ Event Loop ◄──┼───┼─────┼─┤ Microtast Q   │ │ 
│ └──────┬────────┘   │     │ └──────┬────────┘ │ 
│        ▼             │     │        ▼          │ 
│ ┌───────────────┐   │     │ ┌───────────────┐ │ 
│ │ Macrotask Q   │   │     │ │ Call Stack    │ │ 
│ └───────────────┘   │     │ └───────────────┘ │ 
└─────────────────────┘     └─────────────────────┘ 
```

箭头方向表明:*Browser是控制流的主导方*,V7仅响应宿主调⽤ 